const TOKEN_STRINGS = 
[	
	c"@",
	c"string",
	c"char",
	c"int",
	c"float",
	c"ident",
	c"end",
	c"lquote",
	c"rquoute",
	c"func",
	c"while",
	c"if",
	c"else",
	c"loop",
	c"continue",
	c"break",
	c"return",
	c"true",
	c"false",
	c"null",
	c"inline",
	c"import",
	c"extern",
	c"enum",
	c"struct",
	c"const",
	c"sizeof",
	c"underscore",
	c"var",
	c"defer",
	c"$",
	c"+",
	c"-",
	c"*",
	c"/",
	c"%",
	c"!",
	c"(",
	c")",
	c"[",
	c"]",
	c"{",
	c"}",
	c",",
	c";",
	c".",
	c":",
	c"::",
	c"->",
	c"~",
	c"|",
	c"&",
	c"^",
	c"&&",
	c"||",
	c"internal",
	c"for",
	c"=",
	c"==",
	c">",
	c"<",
	c">=",
	c"<=",
	c"!=",
	c"as",
	c">>",
	c"<<",
	c"C string"

] 
const TOK_AT: int = 0
const TOK_STR: int = 1
const TOK_CHAR: int = 2
const TOK_INT: int = 3
const TOK_FLOAT: int = 4
const TOK_IDENT: int = 5
const TOK_END: int = 6
const TOK_LQUOTE: int = 7
const TOK_RQUOTE: int = 8
const TOK_FUN: int = 9
const TOK_WHILE: int = 10
const TOK_IF: int = 11
const TOK_ELSE: int = 12
const TOK_LOOP: int = 13
const TOK_CONTINUE: int = 14
const TOK_BREAK: int = 15
const TOK_RETURN: int = 16
const TOK_TRUE: int = 17
const TOK_FALSE: int = 18
const TOK_NULL: int = 19
const TOK_INLINE: int = 20
const TOK_IMPORT: int = 21
const TOK_EXTERN: int = 22
const TOK_ENUM: int = 23
const TOK_STRUCT: int = 24
const TOK_CONST: int = 25
const TOK_SIZEOF: int = 26
const TOK_UNDERSCORE: int = 27
const TOK_VAR: int = 28
const TOK_DEFER: int = 29
const TOK_DOLLAR: int = 30
const TOK_ADD: int = 31
const TOK_SUB: int = 32
const TOK_MUL: int = 33
const TOK_DIV: int = 34
const TOK_MOD: int = 35
const TOK_NOT: int = 36
const TOK_LPAREN: int = 37
const TOK_RPAREN: int = 38
const TOK_LBRACKET: int = 39
const TOK_RBRACKET: int = 40
const TOK_LBRACE: int = 41
const TOK_RBRACE: int = 42
const TOK_COMMA: int = 43
const TOK_SEMI: int = 44
const TOK_DOT: int = 45
const TOK_COLON: int = 46
const TOK_SEP: int = 47
const TOK_ARROW: int = 48
const TOK_TILDE: int = 49
const TOK_BITOR: int = 50
const TOK_BITAND: int = 51
const TOK_CARET: int = 52
const TOK_AND: int = 53
const TOK_OR: int = 54
const TOK_INTERNAL: int = 55
const TOK_FOR: int = 56
const TOK_EQ: int = 57
const TOK_EQEQ: int = 58
const TOK_GT: int = 59
const TOK_LT: int = 60
const TOK_GE: int = 61
const TOK_LE: int = 62
const TOK_NE: int = 63
const TOK_AS: int = 64
const TOK_GTGT: int = 65
const TOK_LTLT: int = 66
const TOK_CSTR: int = 67


struct Token {
	kind int,
	value *char,
	value2 *char,
	pos Location
}

func is_identifier_start(ch char) bool 
{
	if (ch >='a' && ch <= 'z')  {
		return true
	} else if (ch >= 'A' && ch <= 'Z') {
		return true
	} else if ch == '_' {
		return true
	}
	return false
}

func is_identifier(c char) bool {
	return is_identifier_start(c) || c.is_digit(10 as uint)
}


func empty_token() Token {
	var tok Token 
	tok.kind = TOK_END
	tok.pos = new_location(c"<>",-1,-1)
	return tok
}


func (t Token) is(kind int) bool {
	if t.kind == kind {
		return true
	}

	return false
}

struct Lexer {
	r *Reader
}

func lexer_new(r *Reader) Lexer {
	return Lexer {
		r: r
	}
}

func (l Lexer) cur() char {
	return l.r.cur()
}

func (l Lexer) next() char {
	return l.r.next()
}

func (l *Lexer) read_char() {
	l.r.advance()
	return;
}

func (l Lexer) is_comment_start() bool {
	var c = l.cur()
	if c != 0 as char {
		return c == '/' && l.next() == '/'
	} else {
		return false
	}
	return false
}

func get_keyword_or_ident(val *char,pos Location) Token {
	var tok = empty_token()
	tok.pos = pos
	if strcmp(val,c"func") == 0 {
		tok.kind = TOK_FUN
	} else if strcmp(val,c"struct") == 0 {
		tok.kind = TOK_STRUCT
	} else if strcmp(val,c"const") == 0 {
		tok.kind = TOK_CONST
	} else if strcmp(val,c"var") == 0 {
		tok.kind = TOK_VAR
	} else if strcmp(val,c"extern") == 0 {
		tok.kind = TOK_EXTERN
	} else if strcmp(val,c"else") == 0 {
		tok.kind = TOK_ELSE
	} else if strcmp(val,c"if") == 0 {
		tok.kind = TOK_IF
	} else if strcmp(val,c"while") == 0 {
		tok.kind = TOK_WHILE
	} else if strcmp(val,c"for") == 0 {
		tok.kind = TOK_FOR
	} else if strcmp(val,c"sizeof") == 0 {
		tok.kind = TOK_SIZEOF
	} else if strcmp(val,c"null") == 0 {
		tok.kind = TOK_NULL
	} else if strcmp(val,c"import") == 0 {
		tok.kind = TOK_IMPORT
	} else if strcmp(val,c"false") == 0  {
		tok.kind = TOK_FALSE
	} else if strcmp(val,c"true") == 0 {
		tok.kind = TOK_TRUE
	} else if strcmp(val,c"break") == 0 {
		tok.kind = TOK_BREAK
	} else if strcmp(val,c"continue") == 0 {
		tok.kind = TOK_CONTINUE
	} else if strcmp(val,c"loop") == 0 {
		tok.kind = TOK_LOOP
	} else if strcmp(val,c"as") == 0 {
		tok.kind = TOK_AS
	} else {
		tok.kind = TOK_IDENT
		tok.value = val

		return tok
	}

	tok.value = c""
	tok.value2 = c""

	return tok
}

func (l *Lexer) read_escaped_char(pos Location,unclosed *char) char {
	if l.cur() != '\0' {
		var c = l.cur()
		l.read_char()
		if c == '\\' {
			var ch = 0 as char
			if l.cur() != 0 as char {
				ch = l.cur()
			} else {
				error_at(pos,c"unclosed character")
			}

			l.read_char()

			if ch == '\\' {
				return '\\'
			} else if ch == 'n' {
				return '\n'
			} else if ch == 't' {
				return '\t' 
			} else if ch == 'r' {
				return '\r'
			} else if ch == '\"' {
				return '\"'
			} else if ch == '0' {
				return '0'
			} else {
				var ps = pos.to_string()
				printf(c"%s: ",ps)
				printf(c"Invalid escape sequence '%c'\n",ch)
				exit(-1)
			}
		} else {
			return c
		}

	} else {
		error_at(pos,c"unclosed character")
	}

	return '\0'
} 

func (l *Lexer) read_identifier() Token {
	var pos = l.r.loc()
	var value = malloc(1) as *char

	var i = 0
	while is_identifier(l.cur()) {
		var ch = l.cur()
		value = realloc(value as *void,i + 2 ) as *char
		value[i] = ch
		l.read_char()
		i = i + 1
	}
	
	value[i] = '\0'
	return get_keyword_or_ident(value,pos)
}

func (l Lexer) loc() Location {
	return l.r.loc()
}

func is_digit_or_underscore(ch char,base int) bool {
	return ch.is_digit(base as uint) || ch == '_'
}

func (l *Lexer) read_number() Token {
	var pos = l.loc()
	var tok = empty_token()
	var base = 0
	var is_hex = false
	var is_bin = false
	if l.cur() == '0' {
		var next = l.next()
		if next != 0 as char {
			if next == 'x' {
				l.read_char()
				l.read_char()
				base = 16 
			} else if next == 'b' {
				l.read_char()
				l.read_char()
				base = 2
			}
		} else {
			base = 10
		}
	} else {
		base = 10
	}

	var buffer = malloc(1) as *char
	var i = 0
	while l.cur() != 0 as char && is_digit_or_underscore(l.cur(),base) {
		buffer = realloc(buffer as *void,i + 1) as *char
		var cur = l.cur()
		l.read_char()
		buffer[i] = cur	
		i = i + 1
	}
	if base == 10 && l.cur() != 0 as char && l.cur() == '.' {
		var n = l.next()
		if !n.is_digit(10 as uint) {

		}
		l.read_char()
		
		buffer = realloc(buffer as *void,i + 1) as *char
		buffer[i] = '.'
		i = i + 1
		while l.cur() != 0 as char && is_digit_or_underscore(l.cur(),base) {
			buffer = realloc(buffer as *void,i + 1) as *char
			buffer[i] = l.cur()	
			l.read_char()
			i = i + 1
		}
		if l.cur() != 0 as char && (l.cur() == 'e' || l.cur() == 'E') {
			buffer = realloc(buffer as *void,i + 1) as *char
			buffer[i] = l.cur()
			i = i + 1
			l.read_char()
			if l.cur() != 0 as char {
				if (l.cur() == '+' || l.cur() == '-') {
					buffer = realloc(buffer as *void,i + 1) as *char
					buffer[i] = l.cur()
					i = i + 1
					l.read_char()
				}
			}
			while l.cur() != 0 as char && is_digit_or_underscore(l.cur(),base) {
				buffer = realloc(buffer as *void,i + 1) as *char
				buffer[i] = l.cur()	
				i = i + 1
			}
		}
		buffer = realloc(buffer as *void,i + 1) as *char
		buffer[i] = 0 as char
		tok.value = buffer
		tok.kind = TOK_FLOAT
		return tok
	}

	buffer = realloc(buffer as *void,i + 1) as *char
	buffer[i] = 0 as char
	
	tok.value = buffer
	tok.kind = TOK_INT
	l.read_char()
	return tok


}



func (l *Lexer) skip_white() {
	var ch = l.cur()
	while ch != 0 as char && ch.is_whitespace() {
		l.read_char()
		ch = l.cur()
	}
	return;
}

func (l *Lexer) read_char_literal() Token 
{
	var pos = l.loc()
	l.read_char()
	var ch = l.read_escaped_char(pos,c"unclosed char")
	if is_single_quote(ch) {
		l.read_char()
		var tok = empty_token()
		var buf = malloc(2) as *char
		sprintf(buf,c"%c",ch)
		tok.value = buf
	} else {
		error_at(pos,c"unclosed character")
	}
}

func (l *Lexer) read_comment() {
	var ch = l.cur()
	while ch != 0 as char && !(ch == '\n') {
		l.read_char()
		ch = l.cur()
	}
}

func (l *Lexer) is_multi_comment_start() bool {
	return l.cur() == '/' && l.next() == '*'
}

func (l *Lexer) is_multi_comment_end() bool {
	return l.cur() == '*' && l.next() == '/'
}

func (l *Lexer) read_multi_line_comment() {
	var pos = l.loc()

	l.read_char()
	l.read_char()

	while l.cur() != '\0' && !l.is_multi_comment_end() {
		l.read_char()
	}

	if l.cur() == '\0' {
		error_at(pos,c"Unclosed comment")
	}

	l.read_char()
	l.read_char()
	return;
}
func is_quote(c char) bool {
	return c == '\"'
}

func is_single_quote(c char) bool {
	return c == '\''
}

func is_operator(c char) bool {
	if c == '^' 
	|| c == '+'
	|| c == '-'
	|| c == '*'
	|| c == '/'
	|| c == '%'
	|| c == '&'
	|| c == '|'
	|| c == ','
	|| c == '='
	|| c == '!'
	|| c == '~'
	|| c == ';'
	|| c == ':'
	|| c == '.'
	|| c == '(' || c == ')'
	|| c == '{' || c == '}'
	|| c == '[' || c == ']'
	|| c == '<' || c == '>'
	{
		
		return true
	} else {
		return false
	}
	return false
}

func (l *Lexer) read_string() Token {
	var pos = l.loc()
	var buffer = malloc(40) as *char
	var i = 0
	l.read_char()
	while l.cur() != 0 as char {
		if is_quote(l.cur()) {
			break
		}
		var ch = l.read_escaped_char(pos,c"unclosed string")
		
		sprintf(buffer,c"%s%c",buffer,ch)
		buffer = realloc(buffer as *void,40 + i) as *char
		i = i + 1
	}
	var res = l.cur() == '\"'
	if res {
		
		l.read_char()
		
		var tok = empty_token()
		tok.kind = TOK_STR
		tok.pos = pos
		tok.value = buffer
		return tok
	} else {
		printf(c"%i\n",l.cur())
		error_at(pos,c"Unclosed string")
	}
}

func (l *Lexer) read_token() Token {
	var tok = empty_token()

	while true {
		l.skip_white()

		var pos = l.loc()
		var ch = l.cur()

		if ch == '\0' {
			tok.kind = TOK_END
			tok.value = c""
			return tok
		}

		if ch.is_digit(10 as uint) {
			return l.read_number()
		} else if l.is_comment_start() {
			l.read_comment()
		} else if ch == 'c' {
			if is_quote(l.next()) {
				l.read_char()

				var str = l.read_string()
				str.kind = TOK_CSTR

				return str
			} else {
				return l.read_identifier()
			}
		} else if l.is_multi_comment_start() {
			l.read_multi_line_comment()
		} else if is_identifier_start(ch) {
			return l.read_identifier()
		} else if is_quote(ch) {
			return l.read_string()
		} else if is_single_quote(ch) {
			return l.read_char_literal()
		} else if is_operator(ch) {
			var op = l.read_operator()
			
			return op
		} else {
			var buf = malloc(40) as *char
			sprintf(buf,c"%s: unknown char '%c'",pos.to_string(),ch)
		}

	}
}

func (l *Lexer) read_operator() Token {
	var tok = empty_token()

	var ch = l.cur()
	l.read_char()
	var nch char 

	var _c = l.cur()
	if _c == 0 as char {
		nch = 'x'
	} else {
		nch = _c
	}
	

	if ch == '+' {
		tok.kind = TOK_ADD
	} else if ch == '-' {
		if nch == '>' {
			l.read_char()
			tok.kind = TOK_ARROW
		} else {
			tok.kind = TOK_SUB
		}
		
	} else if ch == '/' {
		tok.kind = TOK_DIV
	} else if ch == '*' {
		tok.kind = TOK_MUL
	} else if ch == '%' {
		tok.kind = TOK_MOD
	} else if ch == '(' {
		tok.kind = TOK_LPAREN
	} else if ch == ')' {
		tok.kind = TOK_RPAREN
	} else if ch == '[' {
		tok.kind = TOK_LBRACKET
	} else if ch == ']' {
		tok.kind = TOK_RBRACKET
	} else if ch == '{' {
		tok.kind = TOK_LBRACE
	} else if ch == '}' {
		tok.kind = TOK_RBRACE
	} else if ch == '|' {
		if nch == '|' {
			l.read_char()
			tok.kind = TOK_OR
		} else {
			tok.kind = TOK_BITOR
		}
	} else if ch == '&' {
		if nch == '&' {
			l.read_char()
			tok.kind = TOK_AND
		} else {
			tok.kind = TOK_BITAND
		}
	} else if ch == '^' {
		tok.kind = TOK_CARET
	} else if ch == '~' {
		tok.kind = TOK_TILDE
	} else if ch == ',' {
		tok.kind = TOK_COMMA
	} else if ch == ';' {
		tok.kind = TOK_SEMI
	} else if ch == ':' {
		tok.kind = TOK_COLON // separator ignored now
	} else if ch == '.' {
		tok.kind = TOK_DOT
	} else if ch == '=' {
		if nch == '=' {
			l.read_char()
			tok.kind = TOK_EQEQ
		} else {
			tok.kind = TOK_EQ
		}
	} else if ch == '<' {
		if nch == '=' {
			l.read_char()
			tok.kind = TOK_LE
		} else if nch == '<' {
			l.read_char()
			tok.kind = TOK_LTLT
		} else {
			tok.kind = TOK_LT
		}
	} else if ch == '>' {
		if nch == '=' {
			l.read_char()
			tok.kind = TOK_GE
		} else if nch == '<' {
			l.read_char()
			tok.kind = TOK_GTGT
		} else {
			tok.kind = TOK_GT
		}
	} else if ch == '!' {
		if nch == '=' {
			l.read_char()
			tok.kind = TOK_NE
		} else {
			tok.kind = TOK_NOT
		}
	} else {
		var pos = l.r.loc()
		var p = pos.to_string()
		printf(c"%s : Unknwon character '%c'",p,ch)
	}
	tok.pos = l.r.loc()
	tok.value = c""
	return tok
}

