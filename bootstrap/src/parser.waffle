struct IdGen {
	id int
}

func (i *IdGen) gen() int {
	var id = i.id
	i.id = i.id + 1
	return id
}

struct Parser {
	idgen IdGen,
	lexer Lexer,
	token Token
}

func parser_new(lexer Lexer) Parser {
	var p Parser
	p.idgen.id = 0
	p.lexer = lexer
	p.token = empty_token()
	return p
}

struct Modifiers {
	inline_ bool,
	extern_ bool,
	static_ bool
}

func (p *Parser) parse_modifiers() Modifiers {
	var m Modifiers
	m.inline_ = false
	m.extern_ = false
	m.static_ = false

	while true {
		var tok = p.token

		if tok.kind == TOK_INLINE {
			if m.inline_ {
				error_at(tok.pos,c"'inline' modifier already set")
			}
			p.advance_token()
			m.inline_ = true
		} else if tok.kind == TOK_EXTERN {
			if m.extern_ {
				error_at(tok.pos,c"'extern' modifier already set")
			}
			p.advance_token()
			m.extern_ = true
		} else {
			break;
		}
	}

	return m
}

func (p *Parser) gen_id() int {
	return p.idgen.gen()
}

func (p *Parser) advance_token() Token {
	var tok = p.lexer.read_token()
	var old = p.token
	p.token = tok
	return old
}

func (p *Parser) expect(kind int) Token {
	if p.token.kind == kind {
		var token = p.advance_token()

		return token
	} else {
		var pos = p.lexer.loc()
		var strings = TOKEN_STRINGS

		printf(c"error %s: Expected '%s',found '%s'",pos.to_string(), strings[kind],strings[p.token.kind])
	}
}

func (p *Parser) expect_identifier() *char {
	var tok = p.advance_token()
	if tok.kind == TOK_IDENT {
		return tok.value
	} else 
	{
		var strings = TOKEN_STRINGS
		printf(c"error %s: Expected identifier,found '%s'",tok.pos.to_string(),strings[tok.kind])
		exit(-1)
	}
}

func (p *Parser) parse_expression() *Expr {
	return null as *Expr
}

func (p *Parser) parse_factor(opts *ExprParsingOpts) *Expr {
	var pos = p.token.pos
	if p.token.kind == TOK_BITAND {
		return p.parse_addrof()
	} else if p.token.kind == TOK_LPAREN {
		return p.parse_parentheses()
	} else if p.token.kind == TOK_LBRACKET {
		return p.parse_array()
	} else if p.token.kind == TOK_MUL {
		return p.parse_deref()
	} else if p.token.kind == TOK_CHAR {
		var expr = calloc(1,sizeof(ExprChar) as int) as *ExprChar
		expr.pos = pos
		expr.kind = EXPR_CHAR
		expr.value = p.token.value[0]
		p.advance_token()
		return expr as *Expr
	} else if p.token.kind == TOK_STR {
		var expr = calloc(1,sizeof(ExprStr) as int) as *ExprStr
		expr.pos = pos
		expr.kind = EXPR_STR
		expr.value = p.token.value
		expr.len = strlen(expr.value)
		p.advance_token()
		return expr as *Expr
	} else if p.token.kind == TOK_CSTR {
		var expr = calloc(1,sizeof(ExprCStr) as int) as *ExprCStr 
		expr.pos = pos
		expr.kind = EXPR_CSTR
		expr.value = p.token.value
		expr.len = strlen(expr.value)
		p.advance_token()
		return expr as *Expr
	} else if p.token.kind == TOK_INT {
		var expr = calloc(1,sizeof(ExprInt) as int) as *ExprInt
		expr.pos = pos
		expr.kind = EXPR_INT
		expr.val = atol(p.token.value)
		p.advance_token()
		return expr as *Expr
	} else if p.token.kind == TOK_FLOAT {
		var expr = calloc(1,sizeof(ExprFloat) as int) as *ExprFloat
		expr.pos = pos
		expr.kind = EXPR_FLOAT
		expr.val = atof(p.token.value)
		p.advance_token()
		return expr as *Expr
	} else if p.token.kind == TOK_TRUE || p.token.kind == TOK_FALSE {
		var expr = calloc(1,sizeof(ExprBool) as int) as *ExprBool
		expr.pos = pos
		expr.kind = EXPR_FLOAT
		expr.value = p.token.kind != TOK_FALSE
		p.advance_token()
		return expr as *Expr
	} else if p.token.kind == TOK_NULL {
		var expr = calloc(1,sizeof(Expr) as int) as *Expr
		expr.kind = EXPR_NULL
		expr.pos = pos
		return expr 
	} 
	return null as *Expr
}


func (p *Parser) parse_array() *Expr {
	var pos = p.advance_token().pos
	var expr = calloc(1,sizeof(ExprArray) as int) as *ExprArray

	
	var values = calloc(1,sizeof(*Expr) as int) as **Expr 
	var count = 0
	while true {
		var val = p.parse_expression()
		values = realloc(values as *void,count + 1) as **Expr
		values[count] = val
		count = count + 1
		if p.token.kind == TOK_COMMA {
			p.expect(TOK_COMMA)
			continue
		} else if p.token.kind == TOK_RBRACKET {
			break
		}
	}
	expr.values = values
	expr.count = count
	expr.pos = pos
	expr.kind = EXPR_ARRAY
	p.advance_token()

	return expr as *Expr
}

func (p *Parser) parse_parentheses() *Expr {
	var pos = p.advance_token().pos
	var exp = p.parse_expression()
	p.expect(TOK_RPAREN)

	var expr = calloc(1,sizeof(ExprPar) as int) as *ExprPar
	expr.val = exp
	expr.pos = pos
	expr.kind = EXPR_PAR
	return expr as *Expr
}

func (p *Parser) parse_deref() *Expr {
	var pos = p.advance_token().pos

	var expr = p.parse_expression()
	var dereference = calloc(1,sizeof(ExprDeref) as int) as *ExprDeref
	dereference.val = expr
	dereference.pos = pos
	expr.kind = EXPR_DEREF
	return expr as *Expr
}

func (p *Parser) parse_addrof() *Expr {
	var pos = p.token.pos
	p.expect(TOK_BITAND)
	var expr = p.parse_expression()
	var addrof = calloc(1,sizeof(ExprAddrOf) as int) as *ExprAddrOf
	addrof.val = expr
	addrof.pos = pos
	addrof.kind = EXPR_ADDROF
	return addrof as *Expr
}

struct ExprParsingOpts {
	parse_struct_lit bool
}

func new_expr_opts() ExprParsingOpts {
	return ExprParsingOpts {
		parse_struct_lit: false
	}
}

func (e *ExprParsingOpts) parse_struct_lit(val bool) *ExprParsingOpts {
	e.parse_struct_lit = val
	return e
}

