struct Map {
	keys *uint,
	values **void,
	count int,
	reserved int,
	value_size int
}
func map_new(vsize int) Map {
	var m Map
	m.count = 0
	m.reserved = 8
	m.values = calloc(8,vsize) as **void
	m.keys = calloc(8,4) as *uint
	m.value_size = vsize

	return m
}

func (m *Map) get(key uint) *void {
	for var i =0,i < m.count,i = i + 1 {
		if m.keys[i] == key {
			return m.values[i]
		}
	}	
	return null
}

func (m *Map) insert(key uint,val *void) {
	var maybe_val = m.get(key)
	if maybe_val != null {
		memcpy(maybe_val,val,m.value_size)
	} else {
		m.extend()
		m.values[m.count] = val
		m.keys[m.count] = key
		m.count = m.count + 1
	}
}

func (m *Map) extend() {
	if m.count >= m.reserved {
		var temp = m.values
		var new_buffer = calloc(m.count + 8,m.value_size)
		memcpy(new_buffer as *void,temp as *void,m.count * m.value_size)
	}
}

func hash_cstr(c *char) uint {
	var hash_value = 5381 as uint
	for var i = 0,i < strlen(c), i = i + 1 {
		var ch = c[i] as uint
		hash_value = ((hash_value << 5 as uint) + hash_value) + (ch)
	}

	return hash_value
}

func hash_bytes(bytes *ubyte,count int) uint {
	var hash_value = 5381 as uint
	for var i = 0,i < count,i = i +1 {
		hash_value = ((hash_value << 5 as uint) + hash_value) + (bytes[i] as uint)
	}
	return hash_value
}